# -*- coding: utf-8 -*-
"""GCN_LSTM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X5Mm_Bg2OkyIvPBB1CADV78oxIea6MQA
"""

import tensorflow as tf
import numpy as np
import logging

from spektral.layers import GCNConv
from spektral.utils.convolution import gcn_filter

class GCN_LSTM(tf.keras.Model):
  """
  """
  def __init__(self, nodes, features, prediction_steps, adj, **kwargs):
    super(GCN_LSTM, self).__init__()

    self.logger = logging.getLogger(__name__)
    self.logger.info(__name__ + ' initializing.')

    self.nodes = nodes
    self.features = features
    self.P = prediction_steps
    self.adj = adj

    self.GCN = GCNConv(self.features, activation='relu')
    self.cell = tf.keras.layers.LSTMCell(self.nodes * self.features)
    self.dense = tf.keras.layers.Dense(self.nodes)
    self.logger.info(__name__ + ' initialized.')

  def call(self, inputs):
    B, H, N, F = inputs.shape

    preds = []
    carry = [tf.zeros((B, N * F)), tf.zeros((B, N * F))] # Initial states, matrici di 0 da [B, NF]
    adj =  tf.stack([gcn_filter(self.adj) for b in range(B)])

    for h in range(H):      
      x = self.GCN([inputs[:,h], adj]) # controllare [B,N,F]
      x = tf.reshape(x, (B, N * F)) # controllare [B,NF]
      memory, carry = self.cell(x, carry) # Memory: [B, NF], Carry: [2, [B, NF]]; memory e carry[0] sono identici

    for p in range(self.P):
      memory, carry = self.cell(memory, carry) # Memory: [B, NF], Carry: [2, [B, NF]]; memory e carry[0] sono identici
      preds.append(memory) # [p, [B, NF]]
    preds = tf.stack(preds, axis=1) # [B, P, NF]
    res = self.dense(preds) # [B, P, N]
    return res
